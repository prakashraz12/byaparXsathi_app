/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import * as reactQuery from "@tanstack/react-query";
import {
  useQueriesContext,
  QueriesContext,
  queryKeyFn,
} from "./queries-context";
import { deepMerge } from "./queries-utils";
import type * as Fetcher from "./queries-fetcher";
import { queriesFetch } from "./queries-fetcher";
import type * as Schemas from "./types-schemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type UserControllerGetMeError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerGetMeVariables = QueriesContext["fetcherOptions"];

export const fetchUserControllerGetMe = (
  variables: UserControllerGetMeVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<undefined, UserControllerGetMeError, undefined, {}, {}, {}>({
    url: "/api/v1/user/me",
    method: "get",
    ...variables,
    signal,
  });

export function userControllerGetMeQuery(
  variables: UserControllerGetMeVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function userControllerGetMeQuery(
  variables: UserControllerGetMeVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function userControllerGetMeQuery(
  variables: UserControllerGetMeVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1/user/me",
      operationId: "userControllerGetMe",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchUserControllerGetMe(variables, signal),
  };
}

export const useSuspenseUserControllerGetMe = <TData = undefined,>(
  variables: UserControllerGetMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UserControllerGetMeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    UserControllerGetMeError,
    TData
  >({
    ...userControllerGetMeQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useUserControllerGetMe = <TData = undefined,>(
  variables: UserControllerGetMeVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UserControllerGetMeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useQuery<undefined, UserControllerGetMeError, TData>({
    ...userControllerGetMeQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AuthControllerWithEmailError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerWithEmailVariables = {
  body: Schemas.WithEmailDto;
} & QueriesContext["fetcherOptions"];

export const fetchAuthControllerWithEmail = (
  variables: AuthControllerWithEmailVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    AuthControllerWithEmailError,
    Schemas.WithEmailDto,
    {},
    {},
    {}
  >({ url: "/api/v1/auth/with-email", method: "post", ...variables, signal });

export const useAuthControllerWithEmail = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      AuthControllerWithEmailError,
      AuthControllerWithEmailVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useQueriesContext();
  return reactQuery.useMutation<
    undefined,
    AuthControllerWithEmailError,
    AuthControllerWithEmailVariables
  >({
    mutationFn: (variables: AuthControllerWithEmailVariables) =>
      fetchAuthControllerWithEmail(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthControllerWithOtpLoginError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerWithOtpLoginVariables = {
  body: Schemas.LoginDto;
} & QueriesContext["fetcherOptions"];

export const fetchAuthControllerWithOtpLogin = (
  variables: AuthControllerWithOtpLoginVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    Schemas.TLoginWithOtpResponse,
    AuthControllerWithOtpLoginError,
    Schemas.LoginDto,
    {},
    {},
    {}
  >({ url: "/api/v1/auth/otp-login", method: "post", ...variables, signal });

export const useAuthControllerWithOtpLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TLoginWithOtpResponse,
      AuthControllerWithOtpLoginError,
      AuthControllerWithOtpLoginVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useQueriesContext();
  return reactQuery.useMutation<
    Schemas.TLoginWithOtpResponse,
    AuthControllerWithOtpLoginError,
    AuthControllerWithOtpLoginVariables
  >({
    mutationFn: (variables: AuthControllerWithOtpLoginVariables) =>
      fetchAuthControllerWithOtpLogin(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthControllerRefreshTokenError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerRefreshTokenVariables =
  QueriesContext["fetcherOptions"];

export const fetchAuthControllerRefreshToken = (
  variables: AuthControllerRefreshTokenVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    AuthControllerRefreshTokenError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/api/v1/auth/refresh-token",
    method: "post",
    ...variables,
    signal,
  });

export const useAuthControllerRefreshToken = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      AuthControllerRefreshTokenError,
      AuthControllerRefreshTokenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useQueriesContext();
  return reactQuery.useMutation<
    undefined,
    AuthControllerRefreshTokenError,
    AuthControllerRefreshTokenVariables
  >({
    mutationFn: (variables: AuthControllerRefreshTokenVariables) =>
      fetchAuthControllerRefreshToken(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type StorageControllerUploadFileError = Fetcher.ErrorWrapper<undefined>;

export type StorageControllerUploadFileVariables =
  QueriesContext["fetcherOptions"];

export const fetchStorageControllerUploadFile = (
  variables: StorageControllerUploadFileVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    StorageControllerUploadFileError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/storage/upload", method: "post", ...variables, signal });

export const useStorageControllerUploadFile = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      StorageControllerUploadFileError,
      StorageControllerUploadFileVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useQueriesContext();
  return reactQuery.useMutation<
    undefined,
    StorageControllerUploadFileError,
    StorageControllerUploadFileVariables
  >({
    mutationFn: (variables: StorageControllerUploadFileVariables) =>
      fetchStorageControllerUploadFile(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ShopControllerCreateShopError = Fetcher.ErrorWrapper<undefined>;

export type ShopControllerCreateShopVariables = {
  body: Schemas.CreateShopDto;
} & QueriesContext["fetcherOptions"];

export const fetchShopControllerCreateShop = (
  variables: ShopControllerCreateShopVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    ShopControllerCreateShopError,
    Schemas.CreateShopDto,
    {},
    {},
    {}
  >({ url: "/api/v1/shop/create", method: "post", ...variables, signal });

export const useShopControllerCreateShop = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      ShopControllerCreateShopError,
      ShopControllerCreateShopVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useQueriesContext();
  return reactQuery.useMutation<
    undefined,
    ShopControllerCreateShopError,
    ShopControllerCreateShopVariables
  >({
    mutationFn: (variables: ShopControllerCreateShopVariables) =>
      fetchShopControllerCreateShop(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type SalesControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type SalesControllerCreateVariables = {
  body: Schemas.CreateSalesDto;
} & QueriesContext["fetcherOptions"];

export const fetchSalesControllerCreate = (
  variables: SalesControllerCreateVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    SalesControllerCreateError,
    Schemas.CreateSalesDto,
    {},
    {},
    {}
  >({ url: "/api/v1/sales/create", method: "post", ...variables, signal });

export const useSalesControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      SalesControllerCreateError,
      SalesControllerCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useQueriesContext();
  return reactQuery.useMutation<
    undefined,
    SalesControllerCreateError,
    SalesControllerCreateVariables
  >({
    mutationFn: (variables: SalesControllerCreateVariables) =>
      fetchSalesControllerCreate(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type SalesControllerGetAllSalesQueryParams = {
  shopId: number;
  invoiceNumber?: string;
  page: number;
  size: number;
};

export type SalesControllerGetAllSalesError = Fetcher.ErrorWrapper<undefined>;

export type SalesControllerGetAllSalesVariables = {
  queryParams: SalesControllerGetAllSalesQueryParams;
} & QueriesContext["fetcherOptions"];

export const fetchSalesControllerGetAllSales = (
  variables: SalesControllerGetAllSalesVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    SalesControllerGetAllSalesError,
    undefined,
    {},
    SalesControllerGetAllSalesQueryParams,
    {}
  >({ url: "/api/v1/sales/all", method: "get", ...variables, signal });

export function salesControllerGetAllSalesQuery(
  variables: SalesControllerGetAllSalesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function salesControllerGetAllSalesQuery(
  variables: SalesControllerGetAllSalesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function salesControllerGetAllSalesQuery(
  variables: SalesControllerGetAllSalesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1/sales/all",
      operationId: "salesControllerGetAllSales",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchSalesControllerGetAllSales(variables, signal),
  };
}

export const useSuspenseSalesControllerGetAllSales = <TData = undefined,>(
  variables: SalesControllerGetAllSalesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      SalesControllerGetAllSalesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    SalesControllerGetAllSalesError,
    TData
  >({
    ...salesControllerGetAllSalesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useSalesControllerGetAllSales = <TData = undefined,>(
  variables: SalesControllerGetAllSalesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      SalesControllerGetAllSalesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useQuery<undefined, SalesControllerGetAllSalesError, TData>(
    {
      ...salesControllerGetAllSalesQuery(
        variables === reactQuery.skipToken
          ? variables
          : deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    },
  );
};

export type ItemControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type ItemControllerCreateVariables = {
  body: Schemas.CreateItemDto;
} & QueriesContext["fetcherOptions"];

export const fetchItemControllerCreate = (
  variables: ItemControllerCreateVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    ItemControllerCreateError,
    Schemas.CreateItemDto,
    {},
    {},
    {}
  >({ url: "/api/v1/item/create", method: "post", ...variables, signal });

export const useItemControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      ItemControllerCreateError,
      ItemControllerCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useQueriesContext();
  return reactQuery.useMutation<
    undefined,
    ItemControllerCreateError,
    ItemControllerCreateVariables
  >({
    mutationFn: (variables: ItemControllerCreateVariables) =>
      fetchItemControllerCreate(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type QueryOperation =
  | {
      path: "/api/v1/user/me";
      operationId: "userControllerGetMe";
      variables: UserControllerGetMeVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1/sales/all";
      operationId: "salesControllerGetAllSales";
      variables: SalesControllerGetAllSalesVariables | reactQuery.SkipToken;
    };
