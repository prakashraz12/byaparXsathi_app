/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import * as reactQuery from "@tanstack/react-query";
import {
  useQueriesContext,
  QueriesContext,
  queryKeyFn,
} from "./queries-context";
import { deepMerge } from "./queries-utils";
import type * as Fetcher from "./queries-fetcher";
import { queriesFetch } from "./queries-fetcher";
import type * as Schemas from "./types-schemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type UserControllerGetMeError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerGetMeVariables = QueriesContext["fetcherOptions"];

export const fetchUserControllerGetMe = (
  variables: UserControllerGetMeVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<undefined, UserControllerGetMeError, undefined, {}, {}, {}>({
    url: "/api/v1/user/me",
    method: "get",
    ...variables,
    signal,
  });

export function userControllerGetMeQuery(
  variables: UserControllerGetMeVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function userControllerGetMeQuery(
  variables: UserControllerGetMeVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function userControllerGetMeQuery(
  variables: UserControllerGetMeVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1/user/me",
      operationId: "userControllerGetMe",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchUserControllerGetMe(variables, signal),
  };
}

export const useSuspenseUserControllerGetMe = <TData = undefined,>(
  variables: UserControllerGetMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UserControllerGetMeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    UserControllerGetMeError,
    TData
  >({
    ...userControllerGetMeQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useUserControllerGetMe = <TData = undefined,>(
  variables: UserControllerGetMeVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UserControllerGetMeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useQuery<undefined, UserControllerGetMeError, TData>({
    ...userControllerGetMeQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AuthControllerWithEmailError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerWithEmailVariables = {
  body: Schemas.WithEmailDto;
} & QueriesContext["fetcherOptions"];

export const fetchAuthControllerWithEmail = (
  variables: AuthControllerWithEmailVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    AuthControllerWithEmailError,
    Schemas.WithEmailDto,
    {},
    {},
    {}
  >({ url: "/api/v1/auth/with-email", method: "post", ...variables, signal });

export const useAuthControllerWithEmail = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      AuthControllerWithEmailError,
      AuthControllerWithEmailVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useQueriesContext();
  return reactQuery.useMutation<
    undefined,
    AuthControllerWithEmailError,
    AuthControllerWithEmailVariables
  >({
    mutationFn: (variables: AuthControllerWithEmailVariables) =>
      fetchAuthControllerWithEmail(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthControllerWithOtpLoginError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerWithOtpLoginVariables = {
  body: Schemas.LoginDto;
} & QueriesContext["fetcherOptions"];

export const fetchAuthControllerWithOtpLogin = (
  variables: AuthControllerWithOtpLoginVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    Schemas.TLoginWithOtpResponse,
    AuthControllerWithOtpLoginError,
    Schemas.LoginDto,
    {},
    {},
    {}
  >({ url: "/api/v1/auth/otp-login", method: "post", ...variables, signal });

export const useAuthControllerWithOtpLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TLoginWithOtpResponse,
      AuthControllerWithOtpLoginError,
      AuthControllerWithOtpLoginVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useQueriesContext();
  return reactQuery.useMutation<
    Schemas.TLoginWithOtpResponse,
    AuthControllerWithOtpLoginError,
    AuthControllerWithOtpLoginVariables
  >({
    mutationFn: (variables: AuthControllerWithOtpLoginVariables) =>
      fetchAuthControllerWithOtpLogin(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthControllerCompleteSetupError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerCompleteSetupVariables = {
  body: Schemas.CompleteSetupDto;
} & QueriesContext["fetcherOptions"];

export const fetchAuthControllerCompleteSetup = (
  variables: AuthControllerCompleteSetupVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    Schemas.TCompletedSetupResponse,
    AuthControllerCompleteSetupError,
    Schemas.CompleteSetupDto,
    {},
    {},
    {}
  >({
    url: "/api/v1/auth/complete-setup",
    method: "post",
    ...variables,
    signal,
  });

export const useAuthControllerCompleteSetup = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TCompletedSetupResponse,
      AuthControllerCompleteSetupError,
      AuthControllerCompleteSetupVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useQueriesContext();
  return reactQuery.useMutation<
    Schemas.TCompletedSetupResponse,
    AuthControllerCompleteSetupError,
    AuthControllerCompleteSetupVariables
  >({
    mutationFn: (variables: AuthControllerCompleteSetupVariables) =>
      fetchAuthControllerCompleteSetup(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthControllerRevalidateTokenError =
  Fetcher.ErrorWrapper<undefined>;

export type AuthControllerRevalidateTokenVariables =
  QueriesContext["fetcherOptions"];

export const fetchAuthControllerRevalidateToken = (
  variables: AuthControllerRevalidateTokenVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    Schemas.TRevalidateTokenResponse,
    AuthControllerRevalidateTokenError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/api/v1/auth/revalidate-token",
    method: "post",
    ...variables,
    signal,
  });

export const useAuthControllerRevalidateToken = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TRevalidateTokenResponse,
      AuthControllerRevalidateTokenError,
      AuthControllerRevalidateTokenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useQueriesContext();
  return reactQuery.useMutation<
    Schemas.TRevalidateTokenResponse,
    AuthControllerRevalidateTokenError,
    AuthControllerRevalidateTokenVariables
  >({
    mutationFn: (variables: AuthControllerRevalidateTokenVariables) =>
      fetchAuthControllerRevalidateToken(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type StorageControllerUploadFileError = Fetcher.ErrorWrapper<undefined>;

export type StorageControllerUploadFileVariables =
  QueriesContext["fetcherOptions"];

export const fetchStorageControllerUploadFile = (
  variables: StorageControllerUploadFileVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    StorageControllerUploadFileError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/storage/upload", method: "post", ...variables, signal });

export const useStorageControllerUploadFile = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      StorageControllerUploadFileError,
      StorageControllerUploadFileVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useQueriesContext();
  return reactQuery.useMutation<
    undefined,
    StorageControllerUploadFileError,
    StorageControllerUploadFileVariables
  >({
    mutationFn: (variables: StorageControllerUploadFileVariables) =>
      fetchStorageControllerUploadFile(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ShopControllerCreateShopError = Fetcher.ErrorWrapper<undefined>;

export type ShopControllerCreateShopVariables = {
  body: Schemas.CreateShopDto;
} & QueriesContext["fetcherOptions"];

export const fetchShopControllerCreateShop = (
  variables: ShopControllerCreateShopVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    ShopControllerCreateShopError,
    Schemas.CreateShopDto,
    {},
    {},
    {}
  >({ url: "/api/v1/shop/create", method: "post", ...variables, signal });

export const useShopControllerCreateShop = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      ShopControllerCreateShopError,
      ShopControllerCreateShopVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useQueriesContext();
  return reactQuery.useMutation<
    undefined,
    ShopControllerCreateShopError,
    ShopControllerCreateShopVariables
  >({
    mutationFn: (variables: ShopControllerCreateShopVariables) =>
      fetchShopControllerCreateShop(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ShopControllerGetAllShopsError = Fetcher.ErrorWrapper<undefined>;

export type ShopControllerGetAllShopsVariables =
  QueriesContext["fetcherOptions"];

export const fetchShopControllerGetAllShops = (
  variables: ShopControllerGetAllShopsVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    ShopControllerGetAllShopsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/shop/all", method: "get", ...variables, signal });

export function shopControllerGetAllShopsQuery(
  variables: ShopControllerGetAllShopsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function shopControllerGetAllShopsQuery(
  variables: ShopControllerGetAllShopsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function shopControllerGetAllShopsQuery(
  variables: ShopControllerGetAllShopsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1/shop/all",
      operationId: "shopControllerGetAllShops",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchShopControllerGetAllShops(variables, signal),
  };
}

export const useSuspenseShopControllerGetAllShops = <TData = undefined,>(
  variables: ShopControllerGetAllShopsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      ShopControllerGetAllShopsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    ShopControllerGetAllShopsError,
    TData
  >({
    ...shopControllerGetAllShopsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useShopControllerGetAllShops = <TData = undefined,>(
  variables: ShopControllerGetAllShopsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      ShopControllerGetAllShopsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useQuery<undefined, ShopControllerGetAllShopsError, TData>({
    ...shopControllerGetAllShopsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type SalesControllerGetAllSalesQueryParams = {
  shopId: string;
  invoiceNumber?: string;
  page: number;
  size: number;
};

export type SalesControllerGetAllSalesError = Fetcher.ErrorWrapper<undefined>;

export type SalesControllerGetAllSalesVariables = {
  queryParams: SalesControllerGetAllSalesQueryParams;
} & QueriesContext["fetcherOptions"];

export const fetchSalesControllerGetAllSales = (
  variables: SalesControllerGetAllSalesVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    SalesControllerGetAllSalesError,
    undefined,
    {},
    SalesControllerGetAllSalesQueryParams,
    {}
  >({ url: "/api/v1/sales/all", method: "get", ...variables, signal });

export function salesControllerGetAllSalesQuery(
  variables: SalesControllerGetAllSalesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function salesControllerGetAllSalesQuery(
  variables: SalesControllerGetAllSalesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function salesControllerGetAllSalesQuery(
  variables: SalesControllerGetAllSalesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1/sales/all",
      operationId: "salesControllerGetAllSales",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchSalesControllerGetAllSales(variables, signal),
  };
}

export const useSuspenseSalesControllerGetAllSales = <TData = undefined,>(
  variables: SalesControllerGetAllSalesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      SalesControllerGetAllSalesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    SalesControllerGetAllSalesError,
    TData
  >({
    ...salesControllerGetAllSalesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useSalesControllerGetAllSales = <TData = undefined,>(
  variables: SalesControllerGetAllSalesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      SalesControllerGetAllSalesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useQuery<undefined, SalesControllerGetAllSalesError, TData>(
    {
      ...salesControllerGetAllSalesQuery(
        variables === reactQuery.skipToken
          ? variables
          : deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    },
  );
};

export type SalesControllerGetAllSalesItemsError =
  Fetcher.ErrorWrapper<undefined>;

export type SalesControllerGetAllSalesItemsVariables =
  QueriesContext["fetcherOptions"];

export const fetchSalesControllerGetAllSalesItems = (
  variables: SalesControllerGetAllSalesItemsVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    SalesControllerGetAllSalesItemsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/sales/all-items", method: "get", ...variables, signal });

export function salesControllerGetAllSalesItemsQuery(
  variables: SalesControllerGetAllSalesItemsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function salesControllerGetAllSalesItemsQuery(
  variables: SalesControllerGetAllSalesItemsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function salesControllerGetAllSalesItemsQuery(
  variables: SalesControllerGetAllSalesItemsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1/sales/all-items",
      operationId: "salesControllerGetAllSalesItems",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchSalesControllerGetAllSalesItems(variables, signal),
  };
}

export const useSuspenseSalesControllerGetAllSalesItems = <TData = undefined,>(
  variables: SalesControllerGetAllSalesItemsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      SalesControllerGetAllSalesItemsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    SalesControllerGetAllSalesItemsError,
    TData
  >({
    ...salesControllerGetAllSalesItemsQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useSalesControllerGetAllSalesItems = <TData = undefined,>(
  variables: SalesControllerGetAllSalesItemsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      SalesControllerGetAllSalesItemsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useQuery<
    undefined,
    SalesControllerGetAllSalesItemsError,
    TData
  >({
    ...salesControllerGetAllSalesItemsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ItemControllerFindAllItemsError = Fetcher.ErrorWrapper<undefined>;

export type ItemControllerFindAllItemsVariables =
  QueriesContext["fetcherOptions"];

export const fetchItemControllerFindAllItems = (
  variables: ItemControllerFindAllItemsVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    ItemControllerFindAllItemsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/item/getAll", method: "get", ...variables, signal });

export function itemControllerFindAllItemsQuery(
  variables: ItemControllerFindAllItemsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function itemControllerFindAllItemsQuery(
  variables: ItemControllerFindAllItemsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function itemControllerFindAllItemsQuery(
  variables: ItemControllerFindAllItemsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1/item/getAll",
      operationId: "itemControllerFindAllItems",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchItemControllerFindAllItems(variables, signal),
  };
}

export const useSuspenseItemControllerFindAllItems = <TData = undefined,>(
  variables: ItemControllerFindAllItemsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      ItemControllerFindAllItemsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    ItemControllerFindAllItemsError,
    TData
  >({
    ...itemControllerFindAllItemsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useItemControllerFindAllItems = <TData = undefined,>(
  variables: ItemControllerFindAllItemsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      ItemControllerFindAllItemsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useQuery<undefined, ItemControllerFindAllItemsError, TData>(
    {
      ...itemControllerFindAllItemsQuery(
        variables === reactQuery.skipToken
          ? variables
          : deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    },
  );
};

export type SyncControllerPullQueryParams = {
  lastPulledAt?: number;
  shopId?: string;
  fetchShops?: boolean;
};

export type SyncControllerPullError = Fetcher.ErrorWrapper<undefined>;

export type SyncControllerPullVariables = {
  queryParams?: SyncControllerPullQueryParams;
} & QueriesContext["fetcherOptions"];

export const fetchSyncControllerPull = (
  variables: SyncControllerPullVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    Schemas.SyncResponseWrapperDto,
    SyncControllerPullError,
    undefined,
    {},
    SyncControllerPullQueryParams,
    {}
  >({ url: "/api/v1/sync/pull", method: "get", ...variables, signal });

export function syncControllerPullQuery(
  variables: SyncControllerPullVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.SyncResponseWrapperDto>;
};

export function syncControllerPullQuery(
  variables: SyncControllerPullVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.SyncResponseWrapperDto>)
    | reactQuery.SkipToken;
};

export function syncControllerPullQuery(
  variables: SyncControllerPullVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1/sync/pull",
      operationId: "syncControllerPull",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchSyncControllerPull(variables, signal),
  };
}

export const useSuspenseSyncControllerPull = <
  TData = Schemas.SyncResponseWrapperDto,
>(
  variables: SyncControllerPullVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SyncResponseWrapperDto,
      SyncControllerPullError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.SyncResponseWrapperDto,
    SyncControllerPullError,
    TData
  >({
    ...syncControllerPullQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useSyncControllerPull = <TData = Schemas.SyncResponseWrapperDto,>(
  variables: SyncControllerPullVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SyncResponseWrapperDto,
      SyncControllerPullError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useQuery<
    Schemas.SyncResponseWrapperDto,
    SyncControllerPullError,
    TData
  >({
    ...syncControllerPullQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type SyncControllerPushError = Fetcher.ErrorWrapper<undefined>;

export type SyncControllerPushVariables = {
  body: Schemas.PushSyncDto;
} & QueriesContext["fetcherOptions"];

export const fetchSyncControllerPush = (
  variables: SyncControllerPushVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    SyncControllerPushError,
    Schemas.PushSyncDto,
    {},
    {},
    {}
  >({ url: "/api/v1/sync/push", method: "post", ...variables, signal });

export const useSyncControllerPush = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      SyncControllerPushError,
      SyncControllerPushVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useQueriesContext();
  return reactQuery.useMutation<
    undefined,
    SyncControllerPushError,
    SyncControllerPushVariables
  >({
    mutationFn: (variables: SyncControllerPushVariables) =>
      fetchSyncControllerPush(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type CustomerControllerCreateUserError = Fetcher.ErrorWrapper<undefined>;

export type CustomerControllerCreateUserVariables =
  QueriesContext["fetcherOptions"];

export const fetchCustomerControllerCreateUser = (
  variables: CustomerControllerCreateUserVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    CustomerControllerCreateUserError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/customer/create", method: "post", ...variables, signal });

export const useCustomerControllerCreateUser = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      CustomerControllerCreateUserError,
      CustomerControllerCreateUserVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useQueriesContext();
  return reactQuery.useMutation<
    undefined,
    CustomerControllerCreateUserError,
    CustomerControllerCreateUserVariables
  >({
    mutationFn: (variables: CustomerControllerCreateUserVariables) =>
      fetchCustomerControllerCreateUser(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type CustomerControllerGetAllCustomersError =
  Fetcher.ErrorWrapper<undefined>;

export type CustomerControllerGetAllCustomersVariables =
  QueriesContext["fetcherOptions"];

export const fetchCustomerControllerGetAllCustomers = (
  variables: CustomerControllerGetAllCustomersVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    CustomerControllerGetAllCustomersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/customer/all", method: "get", ...variables, signal });

export function customerControllerGetAllCustomersQuery(
  variables: CustomerControllerGetAllCustomersVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function customerControllerGetAllCustomersQuery(
  variables: CustomerControllerGetAllCustomersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function customerControllerGetAllCustomersQuery(
  variables: CustomerControllerGetAllCustomersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1/customer/all",
      operationId: "customerControllerGetAllCustomers",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchCustomerControllerGetAllCustomers(variables, signal),
  };
}

export const useSuspenseCustomerControllerGetAllCustomers = <
  TData = undefined,
>(
  variables: CustomerControllerGetAllCustomersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      CustomerControllerGetAllCustomersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    CustomerControllerGetAllCustomersError,
    TData
  >({
    ...customerControllerGetAllCustomersQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useCustomerControllerGetAllCustomers = <TData = undefined,>(
  variables: CustomerControllerGetAllCustomersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      CustomerControllerGetAllCustomersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useQuery<
    undefined,
    CustomerControllerGetAllCustomersError,
    TData
  >({
    ...customerControllerGetAllCustomersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UserAnalayticsControllerOnBoardingUserError =
  Fetcher.ErrorWrapper<undefined>;

export type UserAnalayticsControllerOnBoardingUserVariables =
  QueriesContext["fetcherOptions"];

export const fetchUserAnalayticsControllerOnBoardingUser = (
  variables: UserAnalayticsControllerOnBoardingUserVariables,
  signal?: AbortSignal,
) =>
  queriesFetch<
    undefined,
    UserAnalayticsControllerOnBoardingUserError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/api/v1/adminx/onboarding-user",
    method: "get",
    ...variables,
    signal,
  });

export function userAnalayticsControllerOnBoardingUserQuery(
  variables: UserAnalayticsControllerOnBoardingUserVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function userAnalayticsControllerOnBoardingUserQuery(
  variables:
    | UserAnalayticsControllerOnBoardingUserVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function userAnalayticsControllerOnBoardingUserQuery(
  variables:
    | UserAnalayticsControllerOnBoardingUserVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1/adminx/onboarding-user",
      operationId: "userAnalayticsControllerOnBoardingUser",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchUserAnalayticsControllerOnBoardingUser(variables, signal),
  };
}

export const useSuspenseUserAnalayticsControllerOnBoardingUser = <
  TData = undefined,
>(
  variables: UserAnalayticsControllerOnBoardingUserVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      UserAnalayticsControllerOnBoardingUserError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    UserAnalayticsControllerOnBoardingUserError,
    TData
  >({
    ...userAnalayticsControllerOnBoardingUserQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useUserAnalayticsControllerOnBoardingUser = <TData = undefined,>(
  variables:
    | UserAnalayticsControllerOnBoardingUserVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      UserAnalayticsControllerOnBoardingUserError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueriesContext(options);
  return reactQuery.useQuery<
    undefined,
    UserAnalayticsControllerOnBoardingUserError,
    TData
  >({
    ...userAnalayticsControllerOnBoardingUserQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/api/v1/user/me";
      operationId: "userControllerGetMe";
      variables: UserControllerGetMeVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1/shop/all";
      operationId: "shopControllerGetAllShops";
      variables: ShopControllerGetAllShopsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1/sales/all";
      operationId: "salesControllerGetAllSales";
      variables: SalesControllerGetAllSalesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1/sales/all-items";
      operationId: "salesControllerGetAllSalesItems";
      variables:
        | SalesControllerGetAllSalesItemsVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1/item/getAll";
      operationId: "itemControllerFindAllItems";
      variables: ItemControllerFindAllItemsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1/sync/pull";
      operationId: "syncControllerPull";
      variables: SyncControllerPullVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1/customer/all";
      operationId: "customerControllerGetAllCustomers";
      variables:
        | CustomerControllerGetAllCustomersVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1/adminx/onboarding-user";
      operationId: "userAnalayticsControllerOnBoardingUser";
      variables:
        | UserAnalayticsControllerOnBoardingUserVariables
        | reactQuery.SkipToken;
    };
